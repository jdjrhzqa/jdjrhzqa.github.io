<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[maven使用问题积累]]></title>
    <url>%2F2018%2F07%2F11%2Fmaven%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[写在前面Maven是一个项目管理和综合工具，能让我们很轻松完成项目构建和自动化测试。本篇以问答的形式对近来被问到过的maven的相关问题做下总结，谨做为知识积累，供大家查阅。后续工作过程中如果大家有遇到这方面的其他问题，欢迎一起补充完善~~ maven的依赖传递Q1: 父pom中使用 声明了A、B的依赖，版本设置为1.0。 版本同为1.0，A、B、C三个项目中，B依赖A，C同时依赖A、B，项目C继承父POM，同时在其项目的pom中加入B依赖，version为2.0。B 2.0 也继承了父pom，同时在其项目的pom中有A 2.0的依赖。这种情况下，对项目C执行mvn package，发现项目C的jar lib中包含的A为1.0版本，B为2.0版本。何解？ A1: 这个问题与maven 的传递性依赖有关，先看官方文档对于传递性依赖的定义及其规则。中文文档可参考，但具体释义建议以官方文档为准。 传递性依赖是maven2.0以后出现的新的特性。当你的项目依赖库A，而库A又依赖库B和库C时，传递性依赖使得你项目添加A依赖时，就能帮你把A依赖的其他库B和C也隐式添加到你的项目中，从而避免去寻找所有依赖。该特性依靠解析远端仓库的依赖库的项目文件得以实现的。传递性依赖没有嵌套深度的限制，但是当出现循环依赖的时候会报错。传递性依赖使得包含的依赖库得以很快增长，因为这个原因，依赖性做了一些限制性规定，来确定选择哪些依赖库。 依赖调解：当依赖库存在多个版本时，遵循最小路径原则，在2.0.9版本以后，如果遇到路径相同的依赖库，遵循最先声明原则。最小路径原则，即存在两个不同版本的库时，优先选择依赖树中路径最短的版本。如果，A、B、C、D依赖关系 A -&gt; B -&gt; C -&gt; D 2.0，而A -&gt; E -&gt; D 1.0，则在构建A时，D1.0会被使用。因为A -&gt; E -&gt; D中从A到D的路径更短。如果需要使用依赖A，应直接使用在pom中显示添加D2.0的依赖。 依赖管理：在传递性依赖或者当没有指定依赖版本时，项目作者可以通过依赖管理直接指定依赖的版本。在前述的例子中，A未直接依赖D，但D是A的依赖库。这时，A可以将D做为依赖管理部分的一个依赖，使用 ，在D可能会被引入的时候，控制D的版本。 依赖范围 – 你可以指定只在当前编译范围内包含合适的依赖 排除依赖 如果项目X依赖于项目Y，项目Y又依赖项目Z，项目X的所有者可以使用”exclusion”元素来显式排除项目Z 可选依赖 – 如果项目Y依赖项目Z，项目Y的所有者可以使用”optional”元素来指定项目Z作为X的可选依赖。那么当项目X依赖项目Y时，X只依赖Y并不依赖Y的可选依赖Z。 依赖管理部分，官方文档给予了更为详细的解释，并给出了一些示例，结合示例，归纳了两条原则： 在传递性依赖中，依赖管理的优先级高于依赖调解 当前pom中依赖声明的优先级高于父pom的依赖声明 以上内容均从官方文档获得。从依赖调解和依赖管理两部分内容看，问题中的C-&gt;B-&gt;A, C通过依赖传递获得A的依赖，而在C的父pom中使用dependencyManagement管理确定了A的版本，所以按照依赖管理原则，A的版本为1.0，而B因为在C项目的pom中有声明version，以项目自身pom为准，B的版本为2.0。 maven compiler使用相关Q2: 本地安装了多个jdk版本，希望maven compile在编译一些项目时使用特定版本的jdk，而非缺省jdk版本。 A2:问题可以分为两种情况解答： 本地如果为有桌面系统，可使用IDE工具，建议按照IDE工具的配置方法来设置项目编译使用的JDK版本及编译级别。以IDEA为例，先设置java编译器，file-&gt;setting-&gt;java compile，以jdk1.8为例，设置如下： setting属性设置完成后，进入file-&gt;project structure-&gt;project 设置项目的sdk及编译级别 file-&gt;project structure -&gt;modules 设置各模块的sdk及编译级别 本地如果为linux环境且无可视化界面，可按照maven官方提供的文档来设置项目所需要javac的绝对路径，具体配置123456789101112131415161718192021&lt;project&gt; [...] &lt;build&gt; [...] &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;executable&gt;&lt;!-- path-to-javac --&gt;&lt;/executable&gt; &lt;compilerVersion&gt;1.7&lt;/compilerVersion&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; [...] &lt;/build&gt; [...]&lt;/project&gt; 当然，此处指定的javac版本仅用于maven compiler插件，其他插件仍使用默认jdk版本。 path-to-javac 为本地javac的绝对安装路径， 可以写成硬编码，不过建议最好利用环境变量或者maven的setting.xml文件将该路径做成可配置项。可参考：1&lt;executable&gt;$&#123;JAVA_1_7_HOME&#125;/bin/javac&lt;/executable&gt; 未完待续……]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多模块项目jacoco 覆盖率统计]]></title>
    <url>%2F2018%2F07%2F09%2F%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AEjacoco%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[写在前面jacoco是在我们项目中广泛使用的覆盖率统计工具，关于其特点的介绍、持续集成单元测试覆盖率实例及集成测试覆盖率统计的实例在我们的wiki中有详细介绍，在实际项目中，多模块项目的sonar覆盖率常存在统计不全面的情况，本篇将基于一些实践内容来聊一聊多模块项目的覆盖率统计问题，如有不足之处，欢迎大家评论区留言讨论哦。 关于jacoco的更多信息 多模块项目覆盖率统计遇到的问题知识回顾首先，简单回顾下maven项目中，maven-jacoco插件的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;properties&gt; &lt;!--sonar集成--&gt; &lt;sonar.language&gt;java&lt;/sonar.language&gt; &lt;sonar.dynamicAnalysis&gt;true&lt;/sonar.dynamicAnalysis&gt; &lt;sonar.jacoco.itReportPath&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/sonar.jacoco.itReportPath&gt; &lt;!--排除不需要统计覆盖率的部分，：为分割符--&gt; &lt;sonar.jacoco.excludes&gt; *.exception.*:*.dto.* &lt;/sonar.jacoco.excludes&gt; &lt;!--sonar集成end--&gt;&lt;/properties&gt;&lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.4.201502262128&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includes&gt; &lt;includes&gt;com.test.*&lt;/includes&gt; &lt;includes&gt;com.test2.*&lt;/includes&gt; &lt;/includes&gt; &lt;destFile&gt; $&#123;project.basedir&#125;/target/jacoco.exec &lt;/destFile&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 在程序的verify阶段，执行report测试的程序。 文件的输入为perpare-agent阶段中设置或者默认的jacoco.exec. 参数 includes和excludes可用来选定report中过滤的类。 --&gt; &lt;execution&gt; &lt;id&gt;default-report&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/jacoco&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;!--使用 maven-surefire-plugin来执行单元测试。将surefireArgLine赋值给argLine参数，以保证在测试执行时Jacoco agent处于运行状态。--&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.16&lt;/version&gt; &lt;configuration&gt; &lt;argLine&gt;$&#123;surefireArgLine&#125;&lt;/argLine&gt; &lt;includes&gt; &lt;includes&gt;**/*Test*.java&lt;/includes&gt; &lt;/includes&gt; &lt;/configuration&gt;&lt;/plugin&gt; maven项目集成jacoco插件jacoco-maven-plugin，配置插件执行参数，其中${destFile}为jacoco执行过程中产生的数据信息，${dataFile}属性值与${destFile}相同。 在test完成后，jacoco插件会将${dataFile}属性所代表的exec文件转换为html、xml、csv等格式的报告输出在${outputDirectory}属性中。而由于sonar和jenkins本身都集成了jacoco插件，使用过程中，sonar配置中仅需要指定jacoco exec文件的路径，sonar插件可将exec文件转换为可展示的html文件。1&lt;sonar.jacoco.itReportPath&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/sonar.jacoco.itReportPath&gt; 而jenkins的jacoco配置默认配置会从整个项目中寻找所有的exec文件，并会扫描所有源码和编译后的class文件。当然，如有其它需求，jenkins提供的页面也完全能满足需求了，故项目并不需要对jenkins+jacoco集成再另做配置。 问题引入简单回顾完项目的覆盖率统计，下面来看看多模块项目会遇到什么问题呢。 来看下我们的项目结构。在我们目前项目中，多模块工程的结构大多是根目录和每个模块下都有pom文件，根目录的pom为各module的parent pom文件。对于单元测试而言，每个module都会有对应的测试case，在测试阶段，每个module都会生成自己对应的exec文件，按照上文的配置，对每个module的pom文件的jacoco属性进行配置，则exec文件会存在于各自module的target文件夹下。对于jenkins集成而言，因为可以扫描到所有的exec文件，并会对所有exec文件合并后生成覆盖率报告，多module的工程只要保证有exec文件生成就可正常完成覆盖率统计。对于sonar及本地maven项目的覆盖率，问题会稍微复杂一点。对于maven项目本地覆盖率统计，因为每个module会有对应的exec文件及报告，查看时只能看到单个module的覆盖率情况，不能得到整个项目的单元测试覆盖率 。对于sonar集成，只能解析最后构建的module的exec文件，不能够统计出整个项目的覆盖率。 如果能将不同module的exec文件合并到一个文件中，并能生成对应的覆盖率报告，sonar集成和本地maven项目覆盖率统计的问题就都能解决了。进而将问题分解为两个，第一，将不同module的exec文件合并到一个文件中，满足sonar统计需求。第二由生成的exec生成覆盖率统计报告或者可以直接生成覆盖率报告，满足本地覆盖率报告查看需求。 多module项目jacoco覆盖率sonar集成先解决第一个问题，首先从maven属性入手，是否有属性在同一个项目的不同module的取值相同。从maven官方文档看，maven的属性中，与路径相关的有${project.base.dir} ${project.build.directory}这两个属性，这两种分别代表了当前module的源码路径和当前module的target路径，参考stackoverflow上的高票回答，将所有module的exec文件固定放置在根目录下，具体方案为父pom中配置sonar的属性，sonar.jacoco.reportPaths设置为${project.basedir}/../target/jacoco.exec，即固定在项目根目录的targe路径下。1234567&lt;properties&gt; &lt;sonar.language&gt;java&lt;/sonar.language&gt; &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt; &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt; &lt;sonar.dynamicAnalysis&gt;reuseReports&lt;/sonar.dynamicAnalysis&gt; &lt;sonar.jacoco.reportPaths&gt;$&#123;project.basedir&#125;/../target/jacoco.exec&lt;/sonar.jacoco.reportPaths&gt; &lt;/properties&gt; 对于jacoco插件的配置，与上文最大的区别就是加入了append=true的属性，使得不同exec文件可以合并。1234567891011121314151617&lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt; $&#123;sonar.jacoco.reportPaths&#125; &lt;/destFile&gt; &lt;append&gt;true&lt;/append&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; 其实到这里，sonar多模块的配置问题得到解决了，统一将不同模块的exec文件放置在根目录的jacoco.exec文件中。sonar依据配置属性拿到的文件是包含所有模块数据信息。 思路扩展在解决多模块项目jacoco覆盖率统计问题时，查阅到了jacoco command line interface文档，发现jacoco提供了很多有用的命令行，也完全可以通过使用命令行合并不同的exec文件。此处简单介绍一下，仅为思路扩展。1java -jar jacococli.jar merge [&lt;execfiles&gt; ...] --destfile &lt;path&gt; [--help] [--quiet] jacoco 提供了很多命令行接口，与报告合并的命令如上所示，merge 命令。结合jenkins的exectue shell功能，也可以解决多模块sonar jacoco覆盖率统计问题。做法具体为： 下载jacoco.zip包到jenkins所在机器上，解压后得到jacococli.jar 文件，路径为 /AAAA/bbb 在build pom 中执行构建和测试工作，在每个module中生成exec文件 在build pom的post step中添加 execute shell 12345678java -jar /AAAA/bbb/jacococli.jar merge $&#123;project-dir&#125;/&#123;$module1&#125;/target/jacoco.exec $&#123;project-dir&#125;/&#123;$module2&#125;/target/jacoco.exec ...$&#123;project-dir&#125;/&#123;$modulen&#125;/target/jacoco.exec --destfile $&#123;project-dir&#125;/jacoco.execcp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$module1&#125;/target/jacoco.execcp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$module2&#125;/target/jacoco.exec...cp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$modulen&#125;/target/jacoco.execmvn sonar:sonar 这个解决方法通过命令行将不同模块的exec数据文件合并，并将合并后的文件替换掉各个模块原有文件，之后再执行sonar:sonar命令。方法并不优雅，只是提供一种额外思路。遇到问题总有办法能解决，多看文档没有坏处^ ~ ^。 多模块项目本地覆盖率报告问题解决关于jacoco多模块覆盖率报告的问题，jacoco在17年增加了对多模块项目覆盖率的支持，具体见官方文档。依据官方文档方法，具体操作为： 选择其中一个模块，或者新增一个虚拟模块，确保该模块依赖于该项目的所有其他模块，这样，该模块在生成报告时，其他模块已经执行完成测试和exec数据生成。 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;module1&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;module2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;modulen&lt;/artifactId&gt; &lt;/dependency&gt; . . . &lt;/dependencies&gt; 在选定的module中添加jacoco-maven插件的相关配置，设置目标report-aggregate，关联maven的生命周期 verify 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt; $&#123;sonar.jacoco.reportPaths&#125; &lt;/destFile&gt; &lt;append&gt;true&lt;/append&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 在程序的verify阶段，执行report测试的程序。 文件的输入为perpare-agent阶段中设置或者默认的jacoco.exec. 参数 includes和excludes可用来选定report中过滤的类。 --&gt; &lt;execution&gt; &lt;id&gt;default-report&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;sonar.jacoco.reportPaths&#125;&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/target/site/jacoco&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report-aggregate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 需要注意的是，report-aggregate 这个maven 目标是在jacoco 0.7.7以后才有的功能。 执行项目构建1mvn clean verify -P$profile 构建完成后，在选定模块的target/site/jacoco文件夹中得到jacoco.html文件。打开，即能在本地查阅多模块项目的覆盖率。 其他可能遇到的问题在多模块项目中，有的模块可能不需要单元测试，并没有测试用例，但如果在父pom中统一配置了maven-surefire-plugin插件，运行mvn test时，执行到该模块测试时，可能会因为没有找到测试用例而失败。此处，提供一种可以跳过测试的方法：在模块的pom文件中添加profile，设置跳过测试。123456789101112131415161718192021&lt;profile&gt; &lt;id&gt;noTest&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;noTest&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; 项目执行测试时，执行如下命令即可1mvn test -P$profile -DnoTest=true 至此，多模块项目jacoco单测覆盖率统计问题解决了。 扩展—单元测试与服务端集成测试覆盖率合并及sonar、jenkins集成对于手动场景及集成测试场景自动化测试的覆盖率统计，我们用内部开发的jenkins插件可以dump出报告，不过按照现有的流程，这部分覆盖率还无法在sonar平台上展示，更不能与开发的覆盖率合并显示。前面提到过jacoco command line interface有很多jacoco命令，结合这些命令可以实现sonar展示测试代码覆盖率，及开发测试覆盖率合并。下面将详解介绍配置方法。 以普通服务A为例，A服务的代码仓库中包含源码和所有的测试代码。 step 1: 进入jacoco首页，下载新版本的jacoco-xxx.zip包，解压后，取jacococli.jar包，放置在jenkins 所在机器上，目录为/home/jenkins/jacococli.jar， 路径可随意，jenkins 有权限访问即可。取jacocoagent.jar，放在在A服务启动机器${your-server-ip}上，路径 step 2: 修改服务A的启动脚本脚本，在jvm启动参数中，添加jacoco agent相关参数 “-javaagent:/home/jenkins/jacocoagent.jar=includes=pack.*,output=tcpserver,port=${jacoco-agent-port},address=${your-server-ip}” step 3：jenkins job配置注意事项，在build步骤前新增 per-step，选择execute shell，添加jenkins 自动部署脚本 1$DEPLOY 在pom build 项目构建中选择执行测试，即运行所有单元测试及集成测试case 1clean package -P$&#123;profile&#125; 在build后添加post step，选择 execute shell，添加脚本 1234java /home/jenkins/jacococli.jar dump --address $&#123;your-server-ip&#125; --destfile ./target/jacoco-dump.exec --port $&#123;jacoco-agent-port&#125;java -jar /home/jenkins/jacococli.jar merge ./target/jacoco-dump.exec ./target/jacoco.exec --destfile ./targe/jacoco-aggre.execmv ./target/jacoco-aggre.exec ./target/jacoco.execmvn sonar:sonar 将上述变量替换为实际使用的变量，其中your-server-ip 指的是远端服务部署的机器ip，jacoco-agent-port指的是远端服务的jacoco agent监听端口。 脚本先将远端服务的测试执行数据文件dump到本地 ./target/jacoco-dump.exec，merge 本地单元测试数据文件 ./target/jacoco.exec 和dump下的执行数据文件./target/jacoco-dump.exec 为./targe/jacoco-aggre.exec 文件，为了兼容pom中sonar的配置，将合并后的文件重命名为jacoco.exec，然后添加 mvn sonar:sonar启动sonar分析和结果收集。 job的其他配置不需要改变，build 完成后即可在sonar和jenkins上看到完整的覆盖率报告。 总结本文介绍了多模块项目代码覆盖率sonar集成和本地构建时遇到的问题，分别给出了解决方法。在文末，扩展引申讨论了单元测试覆盖率和测试覆盖率合并统计的问题，结合jacoco官方文档，给出一些建议做法。以上内容，验证可用。如有问题，欢迎留言区讨论~~]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>jacoco</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github博客搭建]]></title>
    <url>%2F2018%2F05%2F28%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo 简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 hexo更多信息 博客搭建博客采用 hexo+github pages方式搭建，选择简洁的NexT主题，因网络上相关资料较多，本文只记录步骤，不做详细介绍。 框架搭建 在github上新建一个仓库，仓库名必须为 “账户名.github.io” 本地安装nodejs 环境，新建文件夹 “账户名.github.io”，安装hexo环境 1234npm install hexonpm hexo initnpm install npm install hexo-deployer-git --save 修改站点配置文件（根目录下_config.yml）,关联本地hexo和git仓库 12345deploy: type: git repo: git@github.com:账户名/账户名.github.io.git branch: master message: &quot;hexo deploy&quot; 当然，配置这个前提是，github上已经配置过ssh key 认证。 编辑站点配置文件_config.yml，添加个人设置 1234567title: 京东金融杭州QAsubtitle:description: 打造业内高精尖白盒测试团队！keywords:author: 白盒测试组language:timezone: hexo 主题选择hexo 提供了很多博客主题，在此选择简约的hexo主题。编辑 hexo 站点配置文件 _config.yml 1theme: next 选择完成后，需要在一级目录themes中添加NexT的源码,具体方法为： 12cd 账户名.github.iogit clone https://github.com/iissnan/hexo-theme-next themes/next 属性设置与博客主题相关的属性设置都在./themes/next/_config.yml文件中，包含博客样式设置，功能主题设置及关联第三方服务的进阶设置。 样式设置，包含Scheme布局设置、头像设置、语言设置、菜单设置、侧栏设置等，具体详见next官网 功能主题设置：设置标签和分类页面。如果菜单设置中添加了tags和categories两个标签，则需要对应生成相应的页面 123cd “账户名.github.io”hexo new page tagshexo new page categories 进阶设置 博客阅读量统计功能设置统计工具选择 leanCloud，在官网上注册用户，新建一个Counter应用,记录应用对应的id 和key，修改主题配置文件 1234leancloud_visitors: enable: true app_id: 应用对应的id app_key: 应用对应的key 评论功能设置曾经红极一时的友言、多说、网易云跟帖相继都关停服务了，而disqus 和facebook 的评论服务器在国外，由于网络限制，用起来也多有不便。调研了一些评论系统，发现leanCloud旗下的评论系统valine，宣称永不停服，相对还是很靠谱的。重要的是NexT 竟然也很好的支持了，意出望外~ 具体配置如下： 1234valine: enable: true appid: 同leanCloud appkey: 同leanCloud pv uv 统计功能设置pv 和uv 统计功能使用busuanzi 来进行统计，最新版本的next对busuanzi的支持很好友，已经不需要像老版本那样通过修改post.ejs文件，关联busuanzi的js脚本来实现了，具体设置： 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 # custom pv span for one page only #page_pv: true #page_pv_header: 本文总阅读量 #page_pv_footer: 次 因为已经有了learnCloud做阅读量统计，这里就不启用busuanzi阅读量的统计了。 分享功能设置分享神器jiathis也停服了，暂时使用百度分享来实现博客内容分享功能。 123baidushare: type: button baidushare: true blog author设置nexT 没有展示博客作者的相关设置，查看了好多文章，没有找到合适的方式。但该功能对于团队博客来说是很重要的，所以去查看了相关源码，找到了markdown渲染的关键代码文件post.swig。对该文件的页面处理逻辑做一些修改，增加了author 标签，目前支持显示blog 的author，但与其他标签相比，缺少好看的样式支持，希望懂前端的同学可以加以补充完善。 博客书写本地环境安装 选择合适的文件夹，下载博客源码前提条件: github账号关联jdjrhzqa Organizations，且github配置过ssh key 12git clone git@github.com:jdjrhzqa/jdjrhzqa.github.io.gitgit checkout hexo hexo 环境安装先安装nodejs，后执行npm install 安装相关依赖 123npm install -g hexo-clinpm installnpm install hexo-deployer-git 如果npm速度较慢，建议切换至淘宝的npm 镜像cnpm来安装，具体方法为： 1234npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g hexo-clicmpm installcnpm install hexo-deployer-git 博客书写与代码提交环境安装完成之后，可以愉快写博客啦，博客书写发布需要掌握hexo的相关命令，具体的操作流程如下： 新建一个提交页面 1hexo new &quot;my new post&quot; 在./source/_posts 目录下找到新建的md 文件，对文件进行编辑操作 md文件中需添加title、categories、tags及author字段，格式可参见已提交博客md文件 md文件编辑完成后，可以在本地运行博客服务，查看内容 123hexo clean hexo generate（or hexo g）hexo server （or hexo s） 其中，hexo clean命令可清理已生成的静态页面，hexo generate 命令将markdown文件渲染成静态页面，可简写为hexo g。而hexo server 命令则在本地启动服务器，用于预览主题，可简写为hexo s。如果想直接预览主题，也可跳过前两个命令，直接执行hexo server。 本地博客展示正常，将代码提交至远端仓库，而后将博客发布到远端服务器上 123git commit -m &quot;xxxx&quot;git push origin hexo deploy （or hexo d） 书写博客注意事项 如果博客内容需要修改，建议直接在原文件中编辑，不要删除替换原有文件。因为生成时间是博客的标识之一，随意修改会影响到该篇博客的统计数据。 仓库里面hexo分支为源码分支，master分支为渲染后的静态页面内容，从github上拉取代码后，注意要切换到hexo分支，代码提交和hexo deploy都在此分支执行。 每次hexo deploy发布博客时，仓库中master分支的内容都会被完全覆盖掉，故如无特殊情况，建议大家不要随意修改或者删除hexo分支中已有的博客内容。]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
