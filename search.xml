<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F11%2Fmaven%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[多模块项目jacoco 覆盖率统计]]></title>
    <url>%2F2018%2F07%2F09%2F%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AEjacoco%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[写在前面jacoco是在我们项目中广泛使用的覆盖率统计工具，关于其特点的介绍、持续集成单元测试覆盖率实例及集成测试覆盖率统计的实例在我们的wiki中有详细介绍，在实际项目中，多模块项目的sonar覆盖率常存在统计不全面的情况，本篇将基于一些实践内容来聊一聊多模块项目的覆盖率统计问题，如有不足之处，欢迎大家评论区留言讨论哦。 关于jacoco的更多信息 多模块项目覆盖率统计遇到的问题知识回顾首先,简单回顾下maven项目中，maven-jacoco插件的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;properties&gt; &lt;!--sonar集成--&gt; &lt;sonar.language&gt;java&lt;/sonar.language&gt; &lt;sonar.branch&gt;$&#123;project.version&#125;&lt;/sonar.branch&gt; &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt; &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt; &lt;sonar.jdbc.url&gt;jdbc:mysql://10.9.0.137:3306/sonarold&lt;/sonar.jdbc.url&gt; &lt;sonar.jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/sonar.jdbc.driver&gt; &lt;sonar.host.url&gt;http://10.9.0.137:29000&lt;/sonar.host.url&gt; &lt;sonar.dynamicAnalysis&gt;true&lt;/sonar.dynamicAnalysis&gt; &lt;sonar.profile&gt;wangyin-plat&lt;/sonar.profile&gt; &lt;sonar.jacoco.itReportPath&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/sonar.jacoco.itReportPath&gt; &lt;!--排除不需要统计覆盖率的部分，：为分割符--&gt; &lt;sonar.jacoco.excludes&gt; *.exception.*:*.dto.* &lt;/sonar.jacoco.excludes&gt; &lt;!--sonar集成end--&gt;&lt;/properties&gt;&lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.4.201502262128&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includes&gt; &lt;includes&gt;com.test.*&lt;/includes&gt; &lt;includes&gt;com.test2.*&lt;/includes&gt; &lt;/includes&gt; &lt;destFile&gt; $&#123;project.basedir&#125;/target/jacoco.exec &lt;/destFile&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 在程序的verify阶段，执行report测试的程序。 文件的输入为perpare-agent阶段中设置或者默认的jacoco.exec. 参数 includes和excludes可用来选定report中过滤的类。 --&gt; &lt;execution&gt; &lt;id&gt;default-report&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/jacoco&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;!--使用 maven-surefire-plugin来执行单元测试。将surefireArgLine赋值给argLine参数，以保证在测试执行时Jacoco agent处于运行状态。--&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.16&lt;/version&gt; &lt;configuration&gt; &lt;argLine&gt;$&#123;surefireArgLine&#125;&lt;/argLine&gt; &lt;includes&gt; &lt;includes&gt;**/*Test*.java&lt;/includes&gt; &lt;/includes&gt; &lt;/configuration&gt;&lt;/plugin&gt; maven项目集成jacoco插件jacoco-maven-plugin，配置插件执行参数，其中${destFile}为jacoco执行过程中产生的数据信息，${dataFile}属性值与${destFile}相同。 在test完成后，jacoco插件会将${dataFile}属性所代表的exec文件转换为html、xml、csv等格式的报告输出在${outputDirectory}属性中。而由于sonar和jenkins本身都集成了jacoco插件，使用过程中，sonar配置中仅需要指定jacoco exec文件的路径，sonar插件可将exec文件转换为可展示的html文件。1&lt;sonar.jacoco.itReportPath&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/sonar.jacoco.itReportPath&gt; 而jenkins的jacoco配置默认配置会从整个项目中寻找所有的exec文件，并会扫描所有源码和编译后的class文件。当然，如有其它需求，jenkins提供的页面也完全能满足需求了，故项目并不需要对jenkins+jacoco集成再另做配置。 问题引入简单回顾完项目的覆盖率统计，下面来看看多模块项目会遇到什么问题呢。 来看下我们的项目结构。在我们目前项目中，多模块工程的结构大多是根目录和每个模块下都有pom文件，根目录的pom为各module的parent pom文件。对于单元测试而言，每个module都会有对应的测试case，在测试阶段，每个module都会生成自己对应的exec文件，按照上文的配置，对每个module的pom文件的jacoco属性进行配置，则exec文件会存在于各自module的target文件夹下。对于jenkins集成而言，因为可以扫描到所有的exec文件，并会对所有exec文件合并后生成覆盖率报告，多module的工程只要保证有exec文件生成就可正常完成覆盖率统计。对于sonar及本地maven项目的覆盖率，问题会稍微复杂一点。对于maven项目本地覆盖率统计，因为每个module会有对应的exec文件及报告，查看时只能看到单个module的覆盖率情况，不能得到整个项目的单元测试覆盖率 。对于sonar集成，只能解析最后构建的module的exec文件，不能够统计出整个项目的覆盖率。 如果能将不同module的exec文件合并到一个文件中，并能生成对应的覆盖率报告，sonar集成和本地maven项目覆盖率统计的问题就都能解决了。进而将问题分解为两个，第一，将不同module的exec文件合并到一个文件中，满足sonar统计需求。第二由生成的exec生成覆盖率统计报告或者可以直接生成覆盖率报告，满足本地覆盖率报告查看需求。 多module项目jacoco覆盖率sonar集成先解决第一个问题，首先从maven属性入手，是否有属性在同一个项目的不同module的取值相同。从maven官方文档看，maven的属性中，与路径相关的有${project.base.dir} ${project.build.directory}这两个属性，这两种分别代表了当前module的源码路径和当前module的target路径，参考stackoverflow上的高票回答，将所有module的exec文件固定放置在根目录下，具体方案为父pom中配置sonar的属性，sonar.jacoco.reportPaths设置为${project.basedir}/../target/jacoco.exec，即固定在项目根目录的targe路径下。1234567&lt;properties&gt; &lt;sonar.language&gt;java&lt;/sonar.language&gt; &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt; &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt; &lt;sonar.dynamicAnalysis&gt;reuseReports&lt;/sonar.dynamicAnalysis&gt; &lt;sonar.jacoco.reportPaths&gt;$&#123;project.basedir&#125;/../target/jacoco.exec&lt;/sonar.jacoco.reportPaths&gt; &lt;/properties&gt; 对于jacoco插件的配置，与上文最大的区别就是加入了append=true的属性，使得不同exec文件可以合并。1234567891011121314151617&lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt; $&#123;sonar.jacoco.reportPaths&#125; &lt;/destFile&gt; &lt;append&gt;true&lt;/append&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; 其实到这里，sonar多模块的配置问题得到解决了，统一将不同模块的exec文件放置在根目录的jacoco.exec文件中。sonar依据配置属性拿到的文件是包含所有模块数据信息。 思路扩展在解决多模块项目jacoco覆盖率统计问题时，查阅到了jacoco command line interface文档，发现jacoco提供了很多有用的命令行，也完全可以通过使用命令行合并不同的exec文件。此处简单介绍一下，仅为思路扩展。1java -jar jacococli.jar merge [&lt;execfiles&gt; ...] --destfile &lt;path&gt; [--help] [--quiet] jacoco 提供了很多命令行接口，与报告合并的命令如上所示，merge 命令。结合jenkins的exectue shell功能，也可以解决多模块sonar jacoco覆盖率统计问题。做法具体为： 下载jacoco.zip包到jenkins所在机器上，解压后得到jacococli.jar 文件，路径为 /AAAA/bbb 在build pom 中执行构建和测试工作，在每个module中生成exec文件 在build pom的post step中添加 execute shell 12345678java -jar /AAAA/bbb/jacococli.jar merge $&#123;project-dir&#125;/&#123;$module1&#125;/target/jacoco.exec $&#123;project-dir&#125;/&#123;$module2&#125;/target/jacoco.exec ...$&#123;project-dir&#125;/&#123;$modulen&#125;/target/jacoco.exec --destfile $&#123;project-dir&#125;/jacoco.execcp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$module1&#125;/target/jacoco.execcp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$module2&#125;/target/jacoco.exec...cp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$modulen&#125;/target/jacoco.execmvn sonar:sonar 这个解决方法通过命令行将不同模块的exec数据文件合并，并将合并后的文件替换掉各个模块原有文件，之后再执行sonar:sonar命令。方法并不优雅，只是提供一种额外思路。遇到问题总有办法能解决，多看文档没有坏处^ ~ ^。 多模块项目本地覆盖率报告问题解决关于jacoco多模块覆盖率报告的问题，jacoco在17年增加了对多模块项目覆盖率的支持，具体见官方文档。依据官方文档方法，具体操作为： 选择其中一个模块，或者新增一个虚拟模块，确保该模块依赖于该项目的所有其他模块，这样，该模块在生成报告时，其他模块已经执行完成测试和exec数据生成。 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;module1&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;module2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;modulen&lt;/artifactId&gt; &lt;/dependency&gt; . . . &lt;/dependencies&gt; 在选定的module中添加jacoco-maven插件的相关配置，设置目标report-aggregate，关联maven的生命周期 verify 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt; $&#123;sonar.jacoco.reportPaths&#125; &lt;/destFile&gt; &lt;append&gt;true&lt;/append&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 在程序的verify阶段，执行report测试的程序。 文件的输入为perpare-agent阶段中设置或者默认的jacoco.exec. 参数 includes和excludes可用来选定report中过滤的类。 --&gt; &lt;execution&gt; &lt;id&gt;default-report&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;sonar.jacoco.reportPaths&#125;&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/target/site/jacoco&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report-aggregate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 需要注意的是，report-aggregate 这个maven 目标是在jacoco 0.7.7以后才有的功能。 执行项目构建1mvn clean verify -P$profile 构建完成后，在选定模块的target/site/jacoco文件夹中得到jacoco.html文件。打开，即能在本地查阅多模块项目的覆盖率。 其他可能遇到的问题在多模块项目中，有的模块可能不需要单元测试，并没有测试用例，但如果在父pom中统一配置了maven-surefire-plugin插件，运行mvn test时，执行到该模块测试时，可能会因为没有找到测试用例而失败。此处，提供一种可以跳过测试的方法：在模块的pom文件中添加profile，设置跳过测试。123456789101112131415161718192021&lt;profile&gt; &lt;id&gt;noTest&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;noTest&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; 项目执行测试时，执行如下命令即可1mvn test -P$profile -DnoTest=true 至此，多模块项目jacoco单测覆盖率统计问题解决了。 扩展—单元测试与服务端集成测试覆盖率合并及sonar、jenkins集成对于手动场景及集成测试场景自动化测试的覆盖率统计，我们用内部开发的jenkins插件可以dump出报告，不过按照现有的流程，这部分覆盖率还无法在sonar平台上展示，更不能与开发的覆盖率合并显示。前面提到过jacoco command line interface有很多jacoco命令，结合这些命令可以实现sonar展示测试代码覆盖率，及开发测试覆盖率合并。下面将详解介绍配置方法。 以普通服务A为例，A服务的代码仓库中包含源码和所有的测试代码。 step 1: 进入jacoco首页,下载新版本的jacoco-xxx.zip包，解压后，取jacococli.jar包，放置在jenkins 所在机器上，目录为/home/jenkins/jacococli.jar， 路径可随意，jenkins 有权限访问即可。取jacocoagent.jar，放在在A服务启动机器${your-server-ip}上，路径 step 2: 修改服务A的启动脚本脚本，在jvm启动参数中，添加jacoco agent相关参数 “-javaagent:/home/local/jacoco/jacocoagent.jar=includes=com.wangyin.*,output=tcpserver,port=6300,address=172.24.2.29” step 3：jenkins job配置注意事项，在build步骤前新增 per-step，选择execute shell,添加jenkins 自动部署脚本 1$DEPLOY 在pom build 项目构建中选择执行测试，即运行所有单元测试及集成测试case 1clean package -P$&#123;profile&#125; 在build后添加post step，选择 execute shell，添加脚本 1234java /home/jenkins/jacococli.jar dump --address $&#123;your-server-ip&#125; --destfile ./target/jacoco-dump.exec --port $&#123;jacoco-agent-port&#125;java -jar /home/jenkins/jacococli.jar merge ./target/jacoco-dump.exec ./target/jacoco.exec --destfile ./targe/jacoco-aggre.execmv ./target/jacoco-aggre.exec ./target/jacoco.execmvn sonar:sonar 将上述变量替换为实际使用的变量，其中your-server-ip 指的是远端服务部署的机器ip，jacoco-agent-port指的是远端服务的jacoco agent监听端口。 脚本先将远端服务的测试执行数据文件dump到本地 ./target/jacoco-dump.exec，merge 本地单元测试数据文件 ./target/jacoco.exec 和dump下的执行数据文件./target/jacoco-dump.exec 为./targe/jacoco-aggre.exec 文件，为了兼容pom中sonar的配置，将合并后的文件重命名为jacoco.exec，然后添加 mvn sonar:sonar启动sonar分析和结果收集。 job的其他配置不需要改变，build 完成后即可在sonar和jenkins上看到完整的覆盖率报告。 总结本文介绍了多模块项目代码覆盖率sonar集成和本地构建时遇到的问题，分别给出了解决方法。在文末，扩展引申讨论了单元测试覆盖率和测试覆盖率合并统计的问题，结合jacoco官方文档，给出一些建议做法。以上内容，验证可用。如有问题，欢迎留言区讨论~~]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>jacoco</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github博客搭建]]></title>
    <url>%2F2018%2F05%2F28%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo 简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 hexo更多信息 博客搭建博客采用 hexo+github pages方式搭建，选择简洁的NexT主题，因网络上相关资料较多，本文只记录步骤，不做详细介绍。 框架搭建 在github上新建一个仓库，仓库名必须为 “账户名.github.io” 本地安装nodejs 环境，新建文件夹 “账户名.github.io”，安装hexo环境 1234npm install hexonpm hexo initnpm install npm install hexo-deployer-git --save 修改站点配置文件（根目录下_config.yml）,关联本地hexo和git仓库 12345deploy: type: git repo: git@github.com:账户名/账户名.github.io.git branch: master message: &quot;hexo deploy&quot; 当然，配置这个前提是，github上已经配置过ssh key 认证。 编辑站点配置文件_config.yml，添加个人设置 1234567title: 京东金融杭州QAsubtitle:description: 打造业内高精尖白盒测试团队！keywords:author: 白盒测试组language:timezone: hexo 主题选择hexo 提供了很多博客主题，在此选择简约的hexo主题。编辑 hexo 站点配置文件 _config.yml 1theme: next 选择完成后，需要在一级目录themes中添加NexT的源码,具体方法为： 12cd 账户名.github.iogit clone https://github.com/iissnan/hexo-theme-next themes/next 属性设置与博客主题相关的属性设置都在./themes/next/_config.yml文件中，包含博客样式设置，功能主题设置及关联第三方服务的进阶设置。 样式设置，包含Scheme布局设置、头像设置、语言设置、菜单设置、侧栏设置等，具体详见next官网 功能主题设置：设置标签和分类页面。如果菜单设置中添加了tags和categories两个标签，则需要对应生成相应的页面 123cd “账户名.github.io”hexo new page tagshexo new page categories 进阶设置 博客阅读量统计功能设置统计工具选择 leanCloud，在官网上注册用户，新建一个Counter应用,记录应用对应的id 和key，修改主题配置文件 1234leancloud_visitors: enable: true app_id: 应用对应的id app_key: 应用对应的key 评论功能设置曾经红极一时的友言、多说、网易云跟帖相继都关停服务了，而disqus 和facebook 的评论服务器在国外，由于网络限制，用起来也多有不便。调研了一些评论系统，发现leanCloud旗下的评论系统valine，宣称永不停服，相对还是很靠谱的。重要的是NexT 竟然也很好的支持了，意出望外~ 具体配置如下： 1234valine: enable: true appid: 同leanCloud appkey: 同leanCloud pv uv 统计功能设置pv 和uv 统计功能使用busuanzi 来进行统计，最新版本的next对busuanzi的支持很好友，已经不需要像老版本那样通过修改post.ejs文件，关联busuanzi的js脚本来实现了，具体设置： 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 # custom pv span for one page only #page_pv: true #page_pv_header: 本文总阅读量 #page_pv_footer: 次 因为已经有了learnCloud做阅读量统计，这里就不启用busuanzi阅读量的统计了。 分享功能设置分享神器jiathis也停服了，暂时使用百度分享来实现博客内容分享功能。 123baidushare: type: button baidushare: true blog author设置nexT 没有展示博客作者的相关设置，查看了好多文章，没有找到合适的方式。但该功能对于团队博客来说是很重要的，所以去查看了相关源码，找到了markdown渲染的关键代码文件post.swig。对该文件的页面处理逻辑做一些修改，增加了author 标签，目前支持显示blog 的author，但与其他标签相比，缺少好看的样式支持，希望懂前端的同学可以加以补充完善。 博客书写本地环境安装 选择合适的文件夹，下载博客源码前提条件: github账号关联jdjrhzqa Organizations，且github配置过ssh key 12git clone git@github.com:jdjrhzqa/jdjrhzqa.github.io.gitgit checkout hexo hexo 环境安装先安装nodejs，后执行npm install 安装相关依赖 123npm install -g hexo-clinpm installnpm install hexo-deployer-git 如果npm速度较慢，建议切换至淘宝的npm 镜像cnpm来安装，具体方法为： 1234npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g hexo-clicmpm installcnpm install hexo-deployer-git 博客书写与代码提交环境安装完成之后，可以愉快写博客啦，博客书写发布需要掌握hexo的相关命令，具体的操作流程如下： 新建一个提交页面 1hexo new &quot;my new post&quot; 在./source/_posts 目录下找到新建的md 文件，对文件进行编辑操作 md文件中需添加title、categories、tags及author字段，格式可参见已提交博客md文件 md文件编辑完成后，可以在本地运行博客服务，查看内容 123hexo clean hexo generate（or hexo g）hexo server （or hexo s） 其中，hexo clean命令可清理已生成的静态页面，hexo generate 命令将markdown文件渲染成静态页面，可简写为hexo g。而hexo server 命令则在本地启动服务器，用于预览主题，可简写为hexo s。如果想直接预览主题，也可跳过前两个命令，直接执行hexo server。 本地博客展示正常，将代码提交至远端仓库，而后将博客发布到远端服务器上 123git commit -m &quot;xxxx&quot;git push origin hexo deploy （or hexo d） 书写博客注意事项 如果博客内容需要修改，建议直接在原文件中编辑，不要删除替换原有文件。因为生成时间是博客的标识之一，随意修改会影响到该篇博客的统计数据。 仓库里面hexo分支为源码分支，master分支为渲染后的静态页面内容，从github上拉取代码后，注意要切换到hexo分支，代码提交和hexo deploy都在此分支执行。 每次hexo deploy发布博客时，仓库中master分支的内容都会被完全覆盖掉，故如无特殊情况，建议大家不要随意修改或者删除hexo分支中已有的博客内容。]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
