<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[性能测试浅说]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%B5%85%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[导语 软件行业飞速发展，时下大数据规模宏盛，人工智能兴起，好不热闹。SDLC 从瀑布到敏捷再到精益化的 devops，持续集成广泛使用。作为测试从业者，迎潮而上，势必要更广泛的渗透到项目始终，传统的黑盒、白盒、性能、自动化、安全方向分类变得模糊，优秀的测试人员无时不刻在项目各阶段不遗余力地集成质量工作，并保持井井有条，不失优雅。本文将讨论性能测试相关内容。 性能测试是什么？在软件工程中，性能测试是一种测试实践，用于确定系统在特定工作负载下的响应性和稳定性方面的表现。它还可用于调查，测量或验证系统的其他质量属性，例如可伸缩性可靠性和资源使用。 什么时候做性能测试？软件性能^1是软件的一种非功能特性，它关注的不是软件是否能够完成特定的功能，而是在完成该功能时展示出来的及时性。 所以说，普遍意义上的性能测试发生在功能测试完成（功能能够正确执行）之后。 一个复杂系统几轮测试至功能稳定，性能测试一跑，发现和线上期望值差别很大，这时候和开发一起调优，如果只是简单的配置优化和局部代码改改就解决了问题固然开心，但万一发现是架构缺陷，这时候调整无异于牵一发而动全身。 我们要做的更好,就应该在项目早期纳入性能集成： 需求阶段，评审出性能需求(性能规格)，比如C端服务场景，至少应该有个用户量和数据量的概念； 设计阶段，对引入的技术栈有基本的性能考量：关注扩展性，关注数据库设计，对引入的外部开源组件查阅或产出 benchmark 报告； 编码阶段，为开发指定一个良好易用的支持并发的单元测试框架（如testng），开发在一些可能发生性能问题的逻辑段or算法中，编写压力单元测试集成。更好的方式是组织代码审查 codereview（不必要、低效的锁、不必要的安全线程设计、糟糕的数据结构、冗余的网络访问…），坚持每天静态代码扫描构建（如sonar），其定义的常见性能缺陷规则在发现疏忽导致的一些低级的性能缺陷很有帮助。 这样一来，再进入普遍意义的性能测试阶段过程，性能不可控风险已经最低，可以把更多精力放在参数调优和容量规划上了。 性能测试目标? 验证软件在特点场景下的性能表现，并枚举一些量化的指标；如当下互联网在线服务领域广泛定义的SLA（服务等级协议），并给出相应的SLI(Service Level Indicator 关键量化指标)； 当1未满足期望的情况下进行调优并使满足(当然相应的量化指标并不总是存在，当然没有人来表达给定用户群的最大可接受响应时间等等的时候，性能测试经常用作性能配置文件调优过程); 在1,2基础上，验证软件or硬件扩展情况下的性能增长表现，并给出合适的容量规划满足生产的服务需求，最终部署到生产环境中，并展开良好的监控经验以持续规划。 性能测试工作？ 确定测试目标 制定性能测试工程的截止目标，如上所说，这往往是多样性的。例如:量化业务的吞吐量指标（可以使用28原则,指80%的业务量在20%的时间里完成）。 设计测试场景 环境选定：性能测试团队通常不在开发/测试环境中执行性能测试，而是在专门的预部署环境中执行，该环境配置尽可能接近计划的生产环境，这通常包含硬件，网络，操作系统，数据库，基础件的约定； 事务：定义关键业务的工作流程 ，事务即关键业务可以是收入价值较高的、被其他项目频繁依赖的、已识别的可能影响系统性能的高风险项等等，这通常是协同性能测试需求方一起评审敲定的； 由简入繁：通常来说，测试场景应遵循由简到繁，先从单一事务，单一维度去分类执行性能测试，然后再过渡到混合的接近真实线上场景事务比率，甚至注入一定数量的随机故障观察系统表现。 编写性能测试脚本 根据设计的测试场景访问形式配合适当的负载工具完成测试脚本的编写/录制。常见如测试web网站可以通过jmeter http 代理服务录制网站业务操作并回放； 分类执行性能测试 下图为性能测试经典负载模型，我们可以按阶段为性能测试分类： 负载测试负载测试(0-b)是最简单的性能测试形式。通常通过不断对系统添加压力进行负载测试以了解系统在特定预期负载下的行为,直到系统出现某些资源耗尽，例如CPU或者网络带宽。 压力测试 压力测试(a-b)通常用于理解系统内容量的上限。进行此类测试是为了确定系统在极端负载方面的稳健性，并帮助应用程序管理员确定如果当前负载远高于预期最大值，系统是否能够充分运行,通常情况下会先进行负载测试，再根据负载测试的结果,确定压力测试的方案。 浸泡\耐久测试（80%a）耐久测试通常在系统资源尚未耗尽的健康范围内让应用承受持续的大量负载，并监视检测潜在的泄漏。确保在一段长时间（N*24h）的持续活动之后的吞吐量或响应时间与测试开始时一样好或更好。 通常来说，上述过程已经覆盖大部分的性能测试需求，更多分类^2可以了解下： 尖峰测试通过突然增加或减少由大量用户产生的负载并观察系统的行为来完成尖峰测试。目标是确定性能是否会受损，系统是否会失败，是否能够处理负载的显着变化。 配置测试不是从负载角度测试性能，而是创建测试以确定系统组件的配置更改对系统性能和行为的影响。一个常见的例子是尝试不同的负载平衡方法。 互联网测试 在真实环境通过一定规模的负载生成器（无论是物理机还是云虚拟机）对生产环境进行性能测试， Facebook, Google and Wikipedia这些全球公司经常这么干 ，这是一种相对较新的性能测试形式。这些测试通常需要大量的准备和监控才能成功执行。 获取性能数据 确保部署和配置性能监视软件来收集所有的关键指标，并可以跟踪一段时间内的趋势，生成监控报告。这一部分同时适用于验证系统已有的监控功能和帮助监控系统的规划。在互联网在线服务，基于服务等级的监控子系统建设往往是必须的。 定位并修复性能问题 在获取的监控结果不符合测试预期的情况下，定位问题并使达成的过程。有时候一个项目没有很好的实践性能集成，导致有些测试无法调整到达成预期，则有必要终止性能测试将系统的各部分返回到开发中进行重构。 基于目标的总结； 总结性能测试结果和生产环境实施，这包括实践性能测试环境中的最优配置，部署持续的性能监视和容量规划方案。 常见的性能关注指标有哪些？ 响应&amp;稳定性 并发用户 顾名思义，这里是系统在任何给定时刻都应支持的最大并发系统用户数。 吞吐量（Hits per second, Request per seconds, Transaction per seconds） 后端服务往往没有用户的概念，那么性能目标往往基于最大吞吐量或事务速率。 响应时间(response time) 指的是一个系统节点响应另一个系统节点的请求所花费的时间 ，如从浏览器客户端到Web服务器的HTTP GET请求。 通常表现形式可以是平均值average，中位值median，百分比分布percentile,不过平均值 or 中位线都只能是一维世界，百分比分布可以更好的图像化（更形象的，更细粒度的）反馈目前系统的响应时间状况。 响应成功率 测试事务断言成功率、超时错误率 可伸缩性 通过增减软件&amp;硬件部署规模达到服务的扩容or缩容，良好的软件设计应该具备好的伸缩性，比如分布式的设计，但是通常来说，添加更多的硬件会导致收益递减； 可靠性 理想系统在任何给定时刻都应该具备高可靠性，比如长时间的不停机运行，突然的峰值交易，部分硬件故障； 资源 服务器：Memory, cache, process, processor, disk and network、open files 网络：Bytes, packets, segments, frames received and sent per sec, Bytes 数据库：缓存命中、索引、连接池、锁 应用：日志、线程池、内存回收 性能测试有哪些好的工具？ 负载工具 开源名牌：Apache JMeter、locust 老牌商业：HP LoadRunner 互联网基于云的在线服务方案：例如loadview-testing 。区别于传统性能测试所有的虚拟用户都来自自己的服务器（这代表测试是在理想条件下进行的 ，甚至不会穿越自己的防火墙）云压测体验往往是端对端的，多地域的，能更好的还原线上真实压力行为，但是显然成本高了，且监控相对复杂，不过个人认为这不影响它成为一种趋势。 服务器资源监控图表工具 小而美：nmon、Jmeter Servers Performance Monitoring 分布式全能：Zabbix 时下火热的云监控：datadog（提供了主流云服务和流行开源项目监控模板整合） 调优工具 JS：JSLitmus、jsperf、chrome profile java：jvisualvm 、JProfiler、Eclipse Memory Analyze(MAT) C\C++: Valgrind、 ccmalloc linux：直接引用系统性能大神Brendan Gregg 的总结和实践perf-tools 待续…]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>理论</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins Pipeline实践分享]]></title>
    <url>%2F2018%2F07%2F27%2FJenkins_pipeline_share%2F</url>
    <content type="text"><![CDATA[前言本文为实践Jenkins Pipeline后的分享，介绍一些本人感受到的pipeline优势、创建pipeline项目的步骤以及调试运行的方法，适合建立过Jenkins项目但是没有接触过其pipeline功能的人群参考. Jenkins Pipeline介绍Jenkins Pipeline是一系列支持执行且集成持续发布pipeline到Jenkins的插件组成的子系统.持续发布pipeline指从版本控制系统中获得软件到交付给用户中间自动化的流程.每次软件更新在发布前都要经过编译打包以及多个测试和开发的场景.Jenkins Pipeline提供一组可扩展的工具通过Pipeline专用语言DSL对简单到复杂的发布Pipeline流程建模实现.Jenkins Pipeline定义成文本文件Jenkinsfile，提交到源码仓库中进行版本维护及审查.使用pipeline，用户可以获得以下优势： 代码：Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流程。 持久化：Pipeline可以在计划和计划外重新启动Jenkins管理时同时存在。 可暂停(交互)：Pipeline可以选择停止并等待人工输入或批准，然后再继续Pipeline运行。 多功能：Pipeline支持复杂的现实世界连续交付要求，包括并行分叉/连接，循环和执行工作的能力。 可扩展：Pipeline插件支持其DSL的自定义扩展以及与其他插件集成的多个选项。 Jenkins自由风格项目先简要介绍下之前未使用pipeline时建立的Jenkins项目以做对比.新建任务-&gt;构建一个自由风格的软件项目 进入项目配置如图 在项目配置里主要有构建和构建后操作模块需要编辑，在本项目中，将参数处理/编译/代码检查/单元测试/集成测试/覆盖率生成的执行均写入shell脚本，通过构建中添加Execute shell步骤执行. 另外在build.sh后面的执行参数是在General模块中参数化构建过程中配置.构建后操作模块中需添加Publish Cppcheck results步骤处理cppcheckreport.xml生成静态代码检查报告，添加Publish Junit test result report步骤处理testreport.xml生成用例运行测试报告，添加Publish HTML reports步骤处理lcov-html目录生成覆盖率报告等.这些文件及目录均为执行shell后生成. 除了这两个模块外，还需要在源码管理模块中填写版本控制软件类型/仓库地址/用户证书/分支号等. Jenkins Pipeline项目新建任务-&gt;流水线，进入项目配置如图 主要模块流水线如图 定义中选择Pipeline script from SCM，表示Pipeline脚本使用SCM仓库中的Jenkinsfile，如果选择选项Pipeline script则会出现脚本的文本编辑框，直接在页面上进行编辑运行. 该项目中编写的Jenkinsfile (Declarative Pipeline) pipeline { agent any//指定在哪台机器上执行任务，配置Node时指定的标签名，any表示任一节点，如果出现在stage内则指定该stage任务在哪台机器执行 stages { stage(&apos;Checkout&apos;) { //定义一个下拉代码的任务 steps {//执行该任务的各个步骤 checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;$Branch&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: &apos;$git_root&apos;]]]) } } stage(&apos;Pre process&apos;) { steps { dir(path: &apos;jenkins/build&apos;) {//切换到某目录下执行，执行完steps会回退到原来所在目录 ... } script { ... REPORT=&quot;jenkins/report&quot; //定义工具和报告的路径变量 } } stage(&apos;Quality Analysis&apos;) { parallel {// 并行运行任务 stage(&apos;Static Analysis&apos;) { ... } stage(&apos;Unit Testing&apos;) { when {//条件判断是否执行该stage，return为真时执行 expression { return params.type == &apos;unit&apos; || params.type == &apos;all&apos; } } steps { sh &quot;./build/${params.Target} --gtest_filter=${params.uargs} --gtest_output= xml:../../../../${UNIT_REPORT}/testreport.xml&quot; //运行gtest生成测试报告 } } } stage(&apos;Code Building&apos;) { ... } stage(&apos;Integration Testing&apos;) { ... } stage(&apos;Coverage HTML Report&apos;) { ... parallel { stage(&apos;Integration Part&apos;) { ... } stage (&apos;Unit Part&apos;) { ... } } } stage(&apos;Coverage Report&apos;) { ... } stage(&apos;Deploy&apos;) { steps { input &quot;Can be deploy into product environment?&quot;//等待手动输入确认 echo &apos;TO DO Deploy&apos; } } } post {//后处理模块,根据pipeline任务执行结果进入不同分支处理,可将该模块定义在stage内单独处理其结果 aborted {//任务中断，Web界面上该任务为灰色的点 echo &apos;Pipeline WAS ABORTED&apos; } always {//始终运行分支 echo &apos;Pipeline finished&apos; ... } changed {//任务状态与上一次不一样 echo &apos;Stage HAVE CHANGED&apos; } failure {//任务失败，Web界面上该任务为红色的点 echo &apos;Stage FAILED&apos; } success {//任务成功，Web界面上该任务为蓝色的点 echo &apos;Stage was Successful&apos; } } options { buildDiscarder(logRotator(numToKeepStr: &apos;10&apos;))//可选项，表示保留最多10个构建日志. } parameters {//可配置任务参数，运行时可在Web界面上配置不同参数 string(name: &apos;git_root&apos;, defaultValue: &apos;http://gitlab.cbpmgt.com/test.git&apos;, description: &apos;git代码路径&apos;) ... string(name: &apos;Tool_Path&apos;, defaultValue: &apos;/home/jenkins/toolkit&apos;, description: &apos;Toolkit路径&apos;) } } 项目对比 Pipeline模式把自由风格模式项目中除了构建触发器外的所有模块都编码到Jenkinsfile文件中，发布配置和代码绑定在一起在SCM进行审查维护，大大增加其可移植性. Pipeline项目执行后可在项目首页形象地看到每个stage执行状态及运行时间. Pipeline日志系统简洁，当某次任务失败，需要找到其失败位置，在自由风格项目中需要点击到该任务的控制台输出，在任务执行的所有日志中查找.而Pipeline项目可直接在项目首页点击任务失败的stage看到原因. Pipeline通过input命令可实现人工介入该过程，更加可靠地判断是否需进行如发布到生产环境的后续步骤. Pipeline通过parallel命令可便捷实现并行任务，加快交付验证的速度. Pipeline开发工具命令行Pipeline LinterJenkins可以在实际运行之前从命令行Jenkins CLI验证声明式Pipeline，本项目用SSH接口运行linter.默认Jenkins的ssh接口是禁用的，需要在Jenkins管理页面上开启: 以管理员身份进入全局安全配置，在SSH Server下选择随机选取即可开启.验证ssh接口是否开启，在需要验证Jenkinsfile的机器A上执行命令获得ssh接口的ip和端口 $ curl -Lv http://$JENKINSURL/login 2&gt;&amp;1 | grep &apos;SSH&apos; &lt; X-SSH-Endpoint: 10.9.0.149:36340 则ssh端口为36340.下一步需配置认证: 将机器A上公钥内容拷贝到https://$JENKINSURL/user/$USERNAME/configure页面上的SSH Public Keys框体中，点击Apply按钮完成.验证密钥认证是否配置成功: $ ssh -v -l $USERNAME -p 36340 10.9.0.149 ...Authentication succeeded (publickey).. 即认证成功. 执行以下命令验证Jenkinsfile语法是否正确 $ ssh -l $USERNAME -p 36340 10.9.0.149 declarative-linter &lt; Jenkinsfile Jenkinsfile successfully validated. Replay调试运行当提交的Jenkinsfile执行后出错或者有其他需要更新时，可以直接使用其Replay功能基于上一次直接在页面上修改.点击上次运行的任务，左侧点击Replay，显示如下. 该功能方便快速更新当前的Pipeline过程，在未最终完成修改时无需对Jenkinsfile进行新的修改提交，最终完成后复制Main Script窗体内容到Jenkinsfile正常提交即可. Blue Ocean插件在Pipeline实践中了解到其相关的插件Blue Ocean，该插件使Pipeline实现及运行的流程更加的可视化.系统管理-&gt;管理插件-&gt;可选插件 中选择Blue Ocean进行安装安装后在自己工程中打开Open Blue Ocean并进入Blue Ocean界面，某次执行任务后视图 视图中显示的之前编写Jenkinsfile文件运行的Pipeline项目各个步骤的运行路径.Blue Ocean界面下可直接创建Pipeline项目.详见BlueOcean 创建Pipeline Pipeline Syntax除了上面的工具外，pipeline项目视图的左侧还有个Pipeline Syntax模块，里面可以在页面上填写便捷地生成很多步骤的脚本. 总结本文对比了自由风格项目与Pipeline项目的区别，重点突出了后者可视化及代码配置可维护的特点，展示pipeline项目的执行效果，最后简要介绍实践中用到的几个开发工具Blue Ocean及Replay等. 参考Jenkins Pipeline官网介绍W3C school Pipeline 介绍BlueOcean介绍]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java微基准工具 -- JMH]]></title>
    <url>%2F2018%2F07%2F20%2Fjava%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7--JMH%2F</url>
    <content type="text"><![CDATA[JMH简介发现JMH这个工具源于阅读jdk8教程时看到了一篇名为Java8 Lambda表达式和流操作如何让你的代码变慢5倍的文章，其在做性能测试时用到了JDK官方的microbenchmark 工具JMH，后来在阅读oracle的lambda表达式的性能研究报告时发现其测试代码也用了JMH工具，以此认为，对于测试同学来说，JMH这个工具是很有必要了解的。 JMH 全称为java mircobenchmark harness。microbenchmark代表其测试粒度可以足够小，可能比测试计时代码本身还要小，此时观察者会影响到被观察者，测试统计结果会出现偏差，所以需要专门的工具。JMH的开发者和JIT开发者是同一个群人，其很大可能会与官方JRE的更新同步，也因为作者更了解JVM，其测试结果会更可靠。 官方对于JMH的介绍惜墨如金，简单总结下来就是： 可用于构建、运行及分析不限于java 等基于jvm语言的毫微、微小及大的基准测试。 方便使用maven快速搭建基准测试工程 JMH目前典型使用的场景有： 在定位到热点方法后，为热点方法进行进一步优化时，可以使用JMH进行定量调优分析。 想定量了解某个方法的执行时长，及参数对执行时长的影响 当方法有两种不同实现时，用JMH确定哪种实现性能更优。 从使用场景上来看，JMH对于我们当前性能测试场景直接使用的意义可能不大，但是对性能测试结果分析和调优会有一些帮助。本篇引入这个工具主要有两个目的，其一是了解官方工具，拓宽一下眼界，二则为性能调优做一些知识积累。 JMH使用项目搭建、构建及运行官方推荐的项目搭建方式是，使用mvn快速搭建一个独立的项目用于基准测试，将应用的jar文件做为依赖引入。这种方法可以更好地保证结果的可靠性。在已有项目或者IDE中运行基准测试也是可行的，但是因启动更加复杂，结果可靠性会降低。 使用JMH的关键在于使用注解或字节码生成器来生成合成的基准代码。maven可以帮助更好的实现这一目的，具体操作步骤如下： 使用maven命令行快速搭建起基准测试工程1234567mvn archetype:generate \ -DinteractiveMode=false \ -DarchetypeGroupId=org.openjdk.jmh \ -DarchetypeArtifactId=jmh-java-benchmark-archetype \ -DgroupId=$&#123;yourself-groupId&#125; \ -DartifactId=test \ -Dversion=$&#123;whatever-you-want&#125; 此处，如果使用了其他jvm 语言，可以将archetypeArtifactId修改成对应语言的，具体参见list 该步骤可以快速搭建使用JMH所需要的所有依赖，并配置好项目的编译打包参数。对于已有项目，可以参照mvn 原型中的pom文件增加JMH相关依赖和maven-shade-plugin插件来配置JMH工程所需。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt; &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;finalName&gt;$&#123;uberjar.name&#125;&lt;/finalName&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;mainClass&gt;org.openjdk.jmh.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;filters&gt; &lt;filter&gt; &lt;!-- Shading signed JARs will fail without this. http://stackoverflow.com/questions/999489/invalid-signature-file-when-attempting-to-run-a-jar --&gt; &lt;artifact&gt;*:*&lt;/artifact&gt; &lt;excludes&gt; &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt; &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt; &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt; &lt;/excludes&gt; &lt;/filter&gt; &lt;/filters&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 执行基准构建12cd /testmvn clean install 该步骤执行mvn install，完成打包并将jar放在本地仓库中。按照pom文件中打包配置，打好的包为可执行jar包。 补充完成基准测试代码，注意代码路径应位于/src/main/java 中, 需要为测试代码添加注解@Benchmark 运行基准测试。命令为1java -jar target/benchmarks.jar 以上为项目快速搭建、构建及执行所需要的命令。 使用示例和说明官方提供了很多示例用于说明工具的使用及注解，但是文档方面的内容几乎没有。下面将结合官网的demo和Java Performance Tuning Guide的文章及其译文对工具如何使用和注解做详细说明。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/* * Copyright (c) 2015, Oracle America, Inc. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright notice, * this list of conditions and the following disclaimer. * * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * * Neither the name of Oracle nor the names of its contributors may be used * to endorse or promote products derived from this software without * specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF * THE POSSIBILITY OF SUCH DAMAGE. */package org.openjdk.jmh.samples;import org.openjdk.jmh.annotations.*;import org.openjdk.jmh.runner.Runner;import org.openjdk.jmh.runner.RunnerException;import org.openjdk.jmh.runner.options.Options;import org.openjdk.jmh.runner.options.OptionsBuilder;import java.util.Arrays;import java.util.Random;import java.util.concurrent.TimeUnit;@BenchmarkMode(Mode.AverageTime)@OutputTimeUnit(TimeUnit.NANOSECONDS)@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)@Fork(5)public class JMHSample_38_PerInvokeSetup &#123; /* * This example highlights the usual mistake in non-steady-state benchmarks. * * Suppose we want to test how long it takes to bubble sort an array. Naively, * we could make the test that populates an array with random (unsorted) values, * and calls sort on it over and over again: */ private void bubbleSort(byte[] b) &#123; boolean changed = true; while (changed) &#123; changed = false; for (int c = 0; c &lt; b.length - 1; c++) &#123; if (b[c] &gt; b[c + 1]) &#123; byte t = b[c]; b[c] = b[c + 1]; b[c + 1] = t; changed = true; &#125; &#125; &#125; &#125; // Could be an implicit State instead, but we are going to use it // as the dependency in one of the tests below @State(Scope.Benchmark) public static class Data &#123; @Param(&#123;&quot;1&quot;, &quot;16&quot;, &quot;256&quot;&#125;) int count; byte[] arr; @Setup public void setup() &#123; arr = new byte[count]; Random random = new Random(1234); random.nextBytes(arr); &#125; &#125; @Benchmark public byte[] measureWrong(Data d) &#123; bubbleSort(d.arr); return d.arr; &#125; /* * The method above is subtly wrong: it sorts the random array on the first invocation * only. Every subsequent call will &quot;sort&quot; the already sorted array. With bubble sort, * that operation would be significantly faster! * * This is how we might *try* to measure it right by making a copy in Level.Invocation * setup. However, this is susceptible to the problems described in Level.Invocation * Javadocs, READ AND UNDERSTAND THOSE DOCS BEFORE USING THIS APPROACH. */ @State(Scope.Thread) public static class DataCopy &#123; byte[] copy; @Setup(Level.Invocation) public void setup2(Data d) &#123; copy = Arrays.copyOf(d.arr, d.arr.length); &#125; &#125; @Benchmark public byte[] measureNeutral(DataCopy d) &#123; bubbleSort(d.copy); return d.copy; &#125; /* * In an overwhelming majority of cases, the only sensible thing to do is to suck up * the per-invocation setup costs into a benchmark itself. This work well in practice, * especially when the payload costs dominate the setup costs. */ @Benchmark public byte[] measureRight(Data d) &#123; byte[] c = Arrays.copyOf(d.arr, d.arr.length); bubbleSort(c); return c; &#125; /* Benchmark (count) Mode Cnt Score Error Units JMHSample_38_PerInvokeSetup.measureWrong 1 avgt 25 2.408 Â± 0.011 ns/op JMHSample_38_PerInvokeSetup.measureWrong 16 avgt 25 8.286 Â± 0.023 ns/op JMHSample_38_PerInvokeSetup.measureWrong 256 avgt 25 73.405 Â± 0.018 ns/op JMHSample_38_PerInvokeSetup.measureNeutral 1 avgt 25 15.835 Â± 0.470 ns/op JMHSample_38_PerInvokeSetup.measureNeutral 16 avgt 25 112.552 Â± 0.787 ns/op JMHSample_38_PerInvokeSetup.measureNeutral 256 avgt 25 58343.848 Â± 991.202 ns/op JMHSample_38_PerInvokeSetup.measureRight 1 avgt 25 6.075 Â± 0.018 ns/op JMHSample_38_PerInvokeSetup.measureRight 16 avgt 25 102.390 Â± 0.676 ns/op JMHSample_38_PerInvokeSetup.measureRight 256 avgt 25 58812.411 Â± 997.951 ns/op We can clearly see that &quot;measureWrong&quot; provides a very weird result: it &quot;sorts&quot; way too fast. &quot;measureNeutral&quot; is neither good or bad: while it prepares the data for each invocation correctly, the timing overheads are clearly visible. These overheads can be overwhelming, depending on the thread count and/or OS flavor. */ /* * ============================== HOW TO RUN THIS TEST: ==================================== * * You can run this test: * * a) Via the command line: * $ mvn clean install * $ java -jar target/benchmarks.jar JMHSample_38 * * b) Via the Java API: * (see the JMH homepage for possible caveats when running from IDE: * http://openjdk.java.net/projects/code-tools/jmh/) */ public static void main(String[] args) throws RunnerException &#123; Options opt = new OptionsBuilder() .include(&quot;.*&quot; + JMHSample_38_PerInvokeSetup.class.getSimpleName() + &quot;.*&quot;) .build(); new Runner(opt).run(); &#125;&#125; 上文示例中给出了对于冒泡排序的jmh示例，同时给出了基准测试方法的正确和错误的示范。先通过示例看官方提供注解的含义，后续再解析如何写正确的基准测试。 注解说明测试控制注解 名称 描述 @Fork 需要运行的试验数量，每个实验运行在独立的jvm进程中。可以指定额外的jvm参数 @Measurement 提供真正的测试阶段参数。指定迭代的次数，每次迭代的运行时间和每次迭代测试调用的数量(通常使用@BenchmarkMode(Mode.SingleShotTime)测试一组操作的开销——而不使用循环) @Warmup 与@Measurement相同，但是用于预热阶段 @Threads 该测试使用的线程数。默认是Runtime.getRuntime().availableProcessors() @BenchmarkMode 测试模式，可以理解为测试结果统计维度 @OutputTimeUnit 指定测试时间单位 测试控制注解可以用于class和method级别，method优先级高于class优先级。 测试模式 测试方法上@BenchmarkMode注解表示使用特定的测试模式，测试模式此处指测试结果统计的维度。 名称 描述 Mode.Throughput 计算一个时间单位内操作数量 Mode.AverageTime 计算平均运行时间 Mode.SampleTime 计算一个方法的运行时间(包括百分位) Mode.SingleShotTime 方法仅运行一次(用于冷测试模式)。或者特定批量大小的迭代多次运行（具体查看“@Measurement”注解）—这种情况下JMH将计算批处理运行时间(一次批处理所有调用的总时间) 任意组合 该测试使用的线程数。默认是Runtime.getRuntime().availableProcessors() Mode.All 所有模式 时间单位 使用@OutputTimeUnit指定时间单位，它需要一个标准Java类型java.util.concurrent.TimeUnit作为参数。可是如果在一个测试中指定了多种测试模式，给定的时间单位将用于所有的测试(比如，测试SampleTime适宜使用纳秒，但是throughput使用更长的时间单位测量更合适)。 测试参数状态 测试方法可以接受参数，需要提供单个参数类，这个类必须遵循以下4条原则: 有无参构造函数(默认构造函数) 是公共类 内部类应该是静态的 该类必须使用@State注解@State注解定义了给定类实例的可用范围。JMH可以在多线程同时运行的环境测试，因此需要选择正确的状态。 名称 描述 Scope.Thread 默认状态。实例将分配给运行给定测试的每个线程。 Scope.Benchmark 运行相同测试的所有线程将共享实例。可以用来测试状态对象的多线程性能 Scope.Group 实例分配给每个线程组 除了单独的类标记@State，也可以将自己的benchmark类标记为@state标记。@Param 注解用于标记 @State对象中基本数据类型参数，@Param注解使用String数组做为参数，这些字符串在任何@SetUp方法被调用前转换为字段类型。 很多情况下，测试代码包含多个参数集合，要测试不同参数集合时，JMH不需要写多个测试方法，准确来说，测试参数是基本类型，基本包装类型或者String时，JMH提供了解决方法。程序中需要完成： 定义@State对象 在其中定义所有的参数字段 每个字段都使用@Param注解 JMH使用所有@Param字段的输出结果，如果第一个字段有2个参数，第二个字段有5个参数，测试将运行2 5 Forks次。 状态设置与清理 与JUnit测试类似，使用@Setup和@TearDown注解标记状态类的方法(这些方法在JMH文档中称为fixtures)。setup/teardown方法的数量是任意的。这些方法不会影响测试时间(但是Level.Invocation可能影响测量精度)。 @Setup/@TearDown注解使用Level参数来指定何时调用fixture： 名称 描述 Level.Trial 默认level。全部benchmark运行(一组迭代)之前/之后 Level.Iteration 一次迭代之前/之后(一组调用) Level.Invocation 每个方法调用之前/之后(不推荐使用，除非你清楚这样做的目的) 示例说明如上示例中，class中声明了5个线程，每个线程迭代运行5次，每次运行一秒钟，取性能测试平均响应时间作为统计维度，在测试执行前预热五次，确保热点方法可以被加载到本地内存中，尽可能接近实际使用场景，输出结果的时间单位为纳秒。 示例中给出了三种基准测试方法，measureWrong使用参数Data，Data参数的scope是整个基准测试阶段，即运行测试的所有线程都使用同一个Data实例，Data中count字段对应三组变量，在setUp时，会将string类型转化为int类型，同时生成对应参数指定长度的随机数组，setUp方法默认为在一组迭代中只初始化一次。在measureWrong方法中会对Data d 做冒泡排序，当第一次冒泡完成后，Data d已经有序的，后续再次执行冒泡排序不会进行位置互换操作，执行速度得到较大提高。这种方法来做基准测试并不能真正反映方法的执行效率。measureNeutral方法使用参数DataCopy对象，DataCopy对象的范围是线程级别，即每个线程会使用一个DataCopy实例。而其setup级别代表方法在每次方法调用前会执行数组copy工作，即能保证每次调用时数组都与第一次执行的数组排序相同。但是官方文档中不并建议使用Invocation级别，除非很清楚如何使用，虽然setup调用时间不会被计算在方法调用时间中，但方法调用 会有一些开销，可能会影响到基准测试的精度。 measureRight方法依然使用Data对象做为传入参数，只是在每次方法调用中使用传入参数的copy，这样保证方法调用不会影响到传入参数。官方给出的建议是，在绝大多数情况下，特别是在setUp方法的开销远小于测试方法时，将setUp中的方法中的每次方法调用放在benchmark中是明智的。 从最终测试结果上看，measureWrong方法的结果比较奇怪，排序速度太快。measureNeutral属于中规中矩的情况，虽然在每次方法调用前都能够保证数据正确性，但是开销是很大的，取决于线程数量和操作系统的情况。与上文分析相同。 使用注意事项对于JMH的使用，除上述内容外，还有以下建议： 不要在测试中使用循环。JIT非常聪明，在循环中经常出现不可预料的处理。要测试真实的计算，让JMH处理剩余的部分。 在非统一开销操作情况下(比如测试处理列表的时间，这个列表在每个测试后有所增加)，你可能使用@BenchmarkMode(Mode.SingleShotTime) 和@Measurement(batchSize = N)。但是不允许你自己实现测试的循环 默认JMH为每个试验(迭代集合)fork一个新的java进程。这样可以防止前面收集的“资料”——其他被加载类以及它们执行的信息对当前测试的影响。比如，实现了相同接口的两个类，测试它们的性能，那么第一个实现(目标测试类)可能比第二个快，因为JIT发现第二个实现类后就把第一个实现的直接方法调用替换为接口方法调用。因此，不要把forks设为0，除非你清楚这样做的目的。极少数情况下需要指定JVM分支数量时，使用@Fork对方法注解，就可以设置分支数量，预热(warmup)迭代数量和JVM分支的其他参数。 可能通过JMH API调用来指定JVM分支参数也有优势——可以使用一些JVM -XX:参数，通过JMH API访问不到它。这样就可以根据你的代码自动选择最佳的JVM设置(new Runner(opt).run()以简便的形式返回了所有的测试结果)。 测试前需要预热，尽量贴近实际使用场景。 其他 IntelliJ 有 JMH 的插件，让jmh的使用和junit一样方便。具体使用方法参看github上相关文档。 在本篇资料收集过程中，发现了国外一些不错的站点，对于java知识学习和性能方面知识积累会有一些帮助，如下： jaxenter java相关资讯和技术 java performance 关注java性能 jenkov的教程 java教程 总结本篇对JMH基准测试工具做了简单介绍，主要关注使用JMH工具的项目搭建、运行和工具关键注解的使用。未尽事项，请参考官方示例。]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>microbenchmark</tag>
        <tag>performance</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven使用问题积累]]></title>
    <url>%2F2018%2F07%2F11%2Fmaven%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[写在前面Maven是一个项目管理和综合工具，能让我们很轻松完成项目构建和自动化测试。本篇以问答的形式对近来被问到过的maven的相关问题做下总结，谨做为知识积累，供大家查阅。后续工作过程中如果大家有遇到这方面的其他问题，欢迎一起补充完善~~ maven的依赖传递Q1: 父pom中使用 声明了A、B的依赖，版本设置为1.0。 版本同为1.0，A、B、C三个项目中，B依赖A，C同时依赖A、B，项目C继承父POM，同时在其项目的pom中加入B依赖，version为2.0。B 2.0 也继承了父pom，同时在其项目的pom中有A 2.0的依赖。这种情况下，对项目C执行mvn package，发现项目C的jar lib中包含的A为1.0版本，B为2.0版本。何解？ A1: 这个问题与maven 的传递性依赖有关，先看官方文档对于传递性依赖的定义及其规则。中文文档可参考，但具体释义建议以官方文档为准。 传递性依赖是maven2.0以后出现的新的特性。当你的项目依赖库A，而库A又依赖库B和库C时，传递性依赖使得你项目添加A依赖时，就能帮你把A依赖的其他库B和C也隐式添加到你的项目中，从而避免去寻找所有依赖。该特性依靠解析远端仓库的依赖库的项目文件得以实现的。传递性依赖没有嵌套深度的限制，但是当出现循环依赖的时候会报错。传递性依赖使得包含的依赖库得以很快增长，因为这个原因，依赖性做了一些限制性规定，来确定选择哪些依赖库。 依赖调解：当依赖库存在多个版本时，遵循最小路径原则，在2.0.9版本以后，如果遇到路径相同的依赖库，遵循最先声明原则。最小路径原则，即存在两个不同版本的库时，优先选择依赖树中路径最短的版本。如果，A、B、C、D依赖关系 A -&gt; B -&gt; C -&gt; D 2.0，而A -&gt; E -&gt; D 1.0，则在构建A时，D1.0会被使用。因为A -&gt; E -&gt; D中从A到D的路径更短。如果需要使用依赖A，应直接使用在pom中显示添加D2.0的依赖。 依赖管理：在传递性依赖或者当没有指定依赖版本时，项目作者可以通过依赖管理直接指定依赖的版本。在前述的例子中，A未直接依赖D，但D是A的依赖库。这时，A可以将D做为依赖管理部分的一个依赖，使用 ，在D可能会被引入的时候，控制D的版本。 依赖范围 – 你可以指定只在当前编译范围内包含合适的依赖 排除依赖 如果项目X依赖于项目Y，项目Y又依赖项目Z，项目X的所有者可以使用”exclusion”元素来显式排除项目Z 可选依赖 – 如果项目Y依赖项目Z，项目Y的所有者可以使用”optional”元素来指定项目Z作为X的可选依赖。那么当项目X依赖项目Y时，X只依赖Y并不依赖Y的可选依赖Z。 依赖管理部分，官方文档给予了更为详细的解释，并给出了一些示例，结合示例，归纳了两条原则： 在传递性依赖中，依赖管理的优先级高于依赖调解 当前pom中依赖声明的优先级高于父pom的依赖声明 以上内容均从官方文档获得。从依赖调解和依赖管理两部分内容看，问题中的C-&gt;B-&gt;A, C通过依赖传递获得A的依赖，而在C的父pom中使用dependencyManagement管理确定了A的版本，所以按照依赖管理原则，A的版本为1.0，而B因为在C项目的pom中有声明version，以项目自身pom为准，B的版本为2.0。 maven compiler使用相关Q2: 本地安装了多个jdk版本，希望maven compile在编译一些项目时使用特定版本的jdk，而非缺省jdk版本。 A2:问题可以分为两种情况解答： 本地如果为有桌面系统，可使用IDE工具，建议按照IDE工具的配置方法来设置项目编译使用的JDK版本及编译级别。以IDEA为例，先设置java编译器，file-&gt;setting-&gt;java compile，以jdk1.8为例，设置如下： setting属性设置完成后，进入file-&gt;project structure-&gt;project 设置项目的sdk及编译级别 file-&gt;project structure -&gt;modules 设置各模块的sdk及编译级别 本地如果为linux环境且无可视化界面，可按照maven官方提供的文档来设置项目所需要javac的绝对路径，具体配置123456789101112131415161718192021&lt;project&gt; [...] &lt;build&gt; [...] &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;executable&gt;&lt;!-- path-to-javac --&gt;&lt;/executable&gt; &lt;compilerVersion&gt;1.7&lt;/compilerVersion&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; [...] &lt;/build&gt; [...]&lt;/project&gt; 当然，此处指定的javac版本仅用于maven compiler插件，其他插件仍使用默认jdk版本。 path-to-javac 为本地javac的绝对安装路径， 可以写成硬编码，不过建议最好利用环境变量或者maven的setting.xml文件将该路径做成可配置项。可参考：1&lt;executable&gt;$&#123;JAVA_1_7_HOME&#125;/bin/javac&lt;/executable&gt; 未完待续……]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多模块项目jacoco 覆盖率统计]]></title>
    <url>%2F2018%2F07%2F09%2F%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AEjacoco%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[写在前面jacoco是在我们项目中广泛使用的覆盖率统计工具，关于其特点的介绍、持续集成单元测试覆盖率实例及集成测试覆盖率统计的实例在我们的wiki中有详细介绍，在实际项目中，多模块项目的sonar覆盖率常存在统计不全面的情况，本篇将基于一些实践内容来聊一聊多模块项目的覆盖率统计问题，如有不足之处，欢迎大家评论区留言讨论哦。 关于jacoco的更多信息 多模块项目覆盖率统计遇到的问题知识回顾首先，简单回顾下maven项目中，maven-jacoco插件的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;properties&gt; &lt;!--sonar集成--&gt; &lt;sonar.language&gt;java&lt;/sonar.language&gt; &lt;sonar.dynamicAnalysis&gt;true&lt;/sonar.dynamicAnalysis&gt; &lt;sonar.jacoco.itReportPath&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/sonar.jacoco.itReportPath&gt; &lt;!--排除不需要统计覆盖率的部分，：为分割符--&gt; &lt;sonar.jacoco.excludes&gt; *.exception.*:*.dto.* &lt;/sonar.jacoco.excludes&gt; &lt;!--sonar集成end--&gt;&lt;/properties&gt;&lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.4.201502262128&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includes&gt; &lt;includes&gt;com.test.*&lt;/includes&gt; &lt;includes&gt;com.test2.*&lt;/includes&gt; &lt;/includes&gt; &lt;destFile&gt; $&#123;project.basedir&#125;/target/jacoco.exec &lt;/destFile&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 在程序的verify阶段，执行report测试的程序。 文件的输入为perpare-agent阶段中设置或者默认的jacoco.exec. 参数 includes和excludes可用来选定report中过滤的类。 --&gt; &lt;execution&gt; &lt;id&gt;default-report&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/jacoco&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;!--使用 maven-surefire-plugin来执行单元测试。将surefireArgLine赋值给argLine参数，以保证在测试执行时Jacoco agent处于运行状态。--&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.16&lt;/version&gt; &lt;configuration&gt; &lt;argLine&gt;$&#123;surefireArgLine&#125;&lt;/argLine&gt; &lt;includes&gt; &lt;includes&gt;**/*Test*.java&lt;/includes&gt; &lt;/includes&gt; &lt;/configuration&gt;&lt;/plugin&gt; maven项目集成jacoco插件jacoco-maven-plugin，配置插件执行参数，其中${destFile}为jacoco执行过程中产生的数据信息，${dataFile}属性值与${destFile}相同。 在test完成后，jacoco插件会将${dataFile}属性所代表的exec文件转换为html、xml、csv等格式的报告输出在${outputDirectory}属性中。而由于sonar和jenkins本身都集成了jacoco插件，使用过程中，sonar配置中仅需要指定jacoco exec文件的路径，sonar插件可将exec文件转换为可展示的html文件。1&lt;sonar.jacoco.itReportPath&gt;$&#123;project.basedir&#125;/target/jacoco.exec&lt;/sonar.jacoco.itReportPath&gt; 而jenkins的jacoco配置默认配置会从整个项目中寻找所有的exec文件，并会扫描所有源码和编译后的class文件。当然，如有其它需求，jenkins提供的页面也完全能满足需求了，故项目并不需要对jenkins+jacoco集成再另做配置。 问题引入简单回顾完项目的覆盖率统计，下面来看看多模块项目会遇到什么问题呢。 来看下我们的项目结构。在我们目前项目中，多模块工程的结构大多是根目录和每个模块下都有pom文件，根目录的pom为各module的parent pom文件。对于单元测试而言，每个module都会有对应的测试case，在测试阶段，每个module都会生成自己对应的exec文件，按照上文的配置，对每个module的pom文件的jacoco属性进行配置，则exec文件会存在于各自module的target文件夹下。对于jenkins集成而言，因为可以扫描到所有的exec文件，并会对所有exec文件合并后生成覆盖率报告，多module的工程只要保证有exec文件生成就可正常完成覆盖率统计。对于sonar及本地maven项目的覆盖率，问题会稍微复杂一点。对于maven项目本地覆盖率统计，因为每个module会有对应的exec文件及报告，查看时只能看到单个module的覆盖率情况，不能得到整个项目的单元测试覆盖率 。对于sonar集成，只能解析最后构建的module的exec文件，不能够统计出整个项目的覆盖率。 如果能将不同module的exec文件合并到一个文件中，并能生成对应的覆盖率报告，sonar集成和本地maven项目覆盖率统计的问题就都能解决了。进而将问题分解为两个，第一，将不同module的exec文件合并到一个文件中，满足sonar统计需求。第二由生成的exec生成覆盖率统计报告或者可以直接生成覆盖率报告，满足本地覆盖率报告查看需求。 多module项目jacoco覆盖率sonar集成先解决第一个问题，首先从maven属性入手，是否有属性在同一个项目的不同module的取值相同。从maven官方文档看，maven的属性中，与路径相关的有${project.base.dir} ${project.build.directory}这两个属性，这两种分别代表了当前module的源码路径和当前module的target路径，参考stackoverflow上的高票回答，将所有module的exec文件固定放置在根目录下，具体方案为父pom中配置sonar的属性，sonar.jacoco.reportPaths设置为${project.basedir}/../target/jacoco.exec，即固定在项目根目录的targe路径下。1234567&lt;properties&gt; &lt;sonar.language&gt;java&lt;/sonar.language&gt; &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt; &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt; &lt;sonar.dynamicAnalysis&gt;reuseReports&lt;/sonar.dynamicAnalysis&gt; &lt;sonar.jacoco.reportPaths&gt;$&#123;project.basedir&#125;/../target/jacoco.exec&lt;/sonar.jacoco.reportPaths&gt; &lt;/properties&gt; 对于jacoco插件的配置，与上文最大的区别就是加入了append=true的属性，使得不同exec文件可以合并。1234567891011121314151617&lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt; $&#123;sonar.jacoco.reportPaths&#125; &lt;/destFile&gt; &lt;append&gt;true&lt;/append&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; 其实到这里，sonar多模块的配置问题得到解决了，统一将不同模块的exec文件放置在根目录的jacoco.exec文件中。sonar依据配置属性拿到的文件是包含所有模块数据信息。 思路扩展在解决多模块项目jacoco覆盖率统计问题时，查阅到了jacoco command line interface文档，发现jacoco提供了很多有用的命令行，也完全可以通过使用命令行合并不同的exec文件。此处简单介绍一下，仅为思路扩展。1java -jar jacococli.jar merge [&lt;execfiles&gt; ...] --destfile &lt;path&gt; [--help] [--quiet] jacoco 提供了很多命令行接口，与报告合并的命令如上所示，merge 命令。结合jenkins的exectue shell功能，也可以解决多模块sonar jacoco覆盖率统计问题。做法具体为： 下载jacoco.zip包到jenkins所在机器上，解压后得到jacococli.jar 文件，路径为 /AAAA/bbb 在build pom 中执行构建和测试工作，在每个module中生成exec文件 在build pom的post step中添加 execute shell 12345678java -jar /AAAA/bbb/jacococli.jar merge $&#123;project-dir&#125;/&#123;$module1&#125;/target/jacoco.exec $&#123;project-dir&#125;/&#123;$module2&#125;/target/jacoco.exec ...$&#123;project-dir&#125;/&#123;$modulen&#125;/target/jacoco.exec --destfile $&#123;project-dir&#125;/jacoco.execcp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$module1&#125;/target/jacoco.execcp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$module2&#125;/target/jacoco.exec...cp -f $&#123;project-dir&#125;/jacoco.exec $&#123;project-dir&#125;/&#123;$modulen&#125;/target/jacoco.execmvn sonar:sonar 这个解决方法通过命令行将不同模块的exec数据文件合并，并将合并后的文件替换掉各个模块原有文件，之后再执行sonar:sonar命令。方法并不优雅，只是提供一种额外思路。遇到问题总有办法能解决，多看文档没有坏处^ ~ ^。 多模块项目本地覆盖率报告问题解决关于jacoco多模块覆盖率报告的问题，jacoco在17年增加了对多模块项目覆盖率的支持，具体见官方文档。依据官方文档方法，具体操作为： 选择其中一个模块，或者新增一个虚拟模块，确保该模块依赖于该项目的所有其他模块，这样，该模块在生成报告时，其他模块已经执行完成测试和exec数据生成。 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;module1&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;module2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;modulen&lt;/artifactId&gt; &lt;/dependency&gt; . . . &lt;/dependencies&gt; 在选定的module中添加jacoco-maven插件的相关配置，设置目标report-aggregate，关联maven的生命周期 verify 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt; $&#123;sonar.jacoco.reportPaths&#125; &lt;/destFile&gt; &lt;append&gt;true&lt;/append&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 在程序的verify阶段，执行report测试的程序。 文件的输入为perpare-agent阶段中设置或者默认的jacoco.exec. 参数 includes和excludes可用来选定report中过滤的类。 --&gt; &lt;execution&gt; &lt;id&gt;default-report&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;sonar.jacoco.reportPaths&#125;&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/target/site/jacoco&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report-aggregate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 需要注意的是，report-aggregate 这个maven 目标是在jacoco 0.7.7以后才有的功能。 执行项目构建1mvn clean verify -P$profile 构建完成后，在选定模块的target/site/jacoco文件夹中得到jacoco.html文件。打开，即能在本地查阅多模块项目的覆盖率。 其他可能遇到的问题在多模块项目中，有的模块可能不需要单元测试，并没有测试用例，但如果在父pom中统一配置了maven-surefire-plugin插件，运行mvn test时，执行到该模块测试时，可能会因为没有找到测试用例而失败。此处，提供一种可以跳过测试的方法：在模块的pom文件中添加profile，设置跳过测试。123456789101112131415161718192021&lt;profile&gt; &lt;id&gt;noTest&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;noTest&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; 项目执行测试时，执行如下命令即可1mvn test -P$profile -DnoTest=true 至此，多模块项目jacoco单测覆盖率统计问题解决了。 扩展—单元测试与服务端集成测试覆盖率合并及sonar、jenkins集成对于手动场景及集成测试场景自动化测试的覆盖率统计，我们用内部开发的jenkins插件可以dump出报告，不过按照现有的流程，这部分覆盖率还无法在sonar平台上展示，更不能与开发的覆盖率合并显示。前面提到过jacoco command line interface有很多jacoco命令，结合这些命令可以实现sonar展示测试代码覆盖率，及开发测试覆盖率合并。下面将详解介绍配置方法。 以普通服务A为例，A服务的代码仓库中包含源码和所有的测试代码。 step 1: 进入jacoco首页，下载新版本的jacoco-xxx.zip包，解压后，取jacococli.jar包，放置在jenkins 所在机器上，目录为/home/jenkins/jacococli.jar， 路径可随意，jenkins 有权限访问即可。取jacocoagent.jar，放在在A服务启动机器${your-server-ip}上，路径 step 2: 修改服务A的启动脚本脚本，在jvm启动参数中，添加jacoco agent相关参数 “-javaagent:/home/jenkins/jacocoagent.jar=includes=pack.*,output=tcpserver,port=${jacoco-agent-port},address=${your-server-ip}” step 3：jenkins job配置注意事项，在build步骤前新增 per-step，选择execute shell，添加jenkins 自动部署脚本 1$DEPLOY 在pom build 项目构建中选择执行测试，即运行所有单元测试及集成测试case 1clean package -P$&#123;profile&#125; 在build后添加post step，选择 execute shell，添加脚本 1234java /home/jenkins/jacococli.jar dump --address $&#123;your-server-ip&#125; --destfile ./target/jacoco-dump.exec --port $&#123;jacoco-agent-port&#125;java -jar /home/jenkins/jacococli.jar merge ./target/jacoco-dump.exec ./target/jacoco.exec --destfile ./targe/jacoco-aggre.execmv ./target/jacoco-aggre.exec ./target/jacoco.execmvn sonar:sonar 将上述变量替换为实际使用的变量，其中your-server-ip 指的是远端服务部署的机器ip，jacoco-agent-port指的是远端服务的jacoco agent监听端口。 脚本先将远端服务的测试执行数据文件dump到本地 ./target/jacoco-dump.exec，merge 本地单元测试数据文件 ./target/jacoco.exec 和dump下的执行数据文件./target/jacoco-dump.exec 为./targe/jacoco-aggre.exec 文件，为了兼容pom中sonar的配置，将合并后的文件重命名为jacoco.exec，然后添加 mvn sonar:sonar启动sonar分析和结果收集。 job的其他配置不需要改变，build 完成后即可在sonar和jenkins上看到完整的覆盖率报告。 总结本文介绍了多模块项目代码覆盖率sonar集成和本地构建时遇到的问题，分别给出了解决方法。在文末，扩展引申讨论了单元测试覆盖率和测试覆盖率合并统计的问题，结合jacoco官方文档，给出一些建议做法。以上内容，验证可用。如有问题，欢迎留言区讨论~~]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>jacoco</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github博客搭建]]></title>
    <url>%2F2018%2F05%2F28%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo 简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 hexo更多信息 博客搭建博客采用 hexo+github pages方式搭建，选择简洁的NexT主题，因网络上相关资料较多，本文只记录步骤，不做详细介绍。 框架搭建 在github上新建一个仓库，仓库名必须为 “账户名.github.io” 本地安装nodejs 环境，新建文件夹 “账户名.github.io”，安装hexo环境 1234npm install hexonpm hexo initnpm install npm install hexo-deployer-git --save 修改站点配置文件（根目录下_config.yml）,关联本地hexo和git仓库 12345deploy: type: git repo: git@github.com:账户名/账户名.github.io.git branch: master message: &quot;hexo deploy&quot; 当然，配置这个前提是，github上已经配置过ssh key 认证。 编辑站点配置文件_config.yml，添加个人设置 1234567title: 京东金融杭州QAsubtitle:description: 打造业内高精尖白盒测试团队！keywords:author: 白盒测试组language:timezone: hexo 主题选择hexo 提供了很多博客主题，在此选择简约的hexo主题。编辑 hexo 站点配置文件 _config.yml 1theme: next 选择完成后，需要在一级目录themes中添加NexT的源码,具体方法为： 12cd 账户名.github.iogit clone https://github.com/iissnan/hexo-theme-next themes/next 属性设置与博客主题相关的属性设置都在./themes/next/_config.yml文件中，包含博客样式设置，功能主题设置及关联第三方服务的进阶设置。 样式设置，包含Scheme布局设置、头像设置、语言设置、菜单设置、侧栏设置等，具体详见next官网 功能主题设置：设置标签和分类页面。如果菜单设置中添加了tags和categories两个标签，则需要对应生成相应的页面 123cd “账户名.github.io”hexo new page tagshexo new page categories 进阶设置 博客阅读量统计功能设置统计工具选择 leanCloud，在官网上注册用户，新建一个Counter应用,记录应用对应的id 和key，修改主题配置文件 1234leancloud_visitors: enable: true app_id: 应用对应的id app_key: 应用对应的key 评论功能设置曾经红极一时的友言、多说、网易云跟帖相继都关停服务了，而disqus 和facebook 的评论服务器在国外，由于网络限制，用起来也多有不便。调研了一些评论系统，发现leanCloud旗下的评论系统valine，宣称永不停服，相对还是很靠谱的。重要的是NexT 竟然也很好的支持了，意出望外~ 具体配置如下： 1234valine: enable: true appid: 同leanCloud appkey: 同leanCloud pv uv 统计功能设置pv 和uv 统计功能使用busuanzi 来进行统计，最新版本的next对busuanzi的支持很好友，已经不需要像老版本那样通过修改post.ejs文件，关联busuanzi的js脚本来实现了，具体设置： 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 # custom pv span for one page only #page_pv: true #page_pv_header: 本文总阅读量 #page_pv_footer: 次 因为已经有了learnCloud做阅读量统计，这里就不启用busuanzi阅读量的统计了。 分享功能设置分享神器jiathis也停服了，暂时使用百度分享来实现博客内容分享功能。 123baidushare: type: button baidushare: true blog author设置nexT 没有展示博客作者的相关设置，查看了好多文章，没有找到合适的方式。但该功能对于团队博客来说是很重要的，所以去查看了相关源码，找到了markdown渲染的关键代码文件post.swig。对该文件的页面处理逻辑做一些修改，增加了author 标签，目前支持显示blog 的author，但与其他标签相比，缺少好看的样式支持，希望懂前端的同学可以加以补充完善。 博客书写本地环境安装 选择合适的文件夹，下载博客源码前提条件: github账号关联jdjrhzqa Organizations，且github配置过ssh key 12git clone git@github.com:jdjrhzqa/jdjrhzqa.github.io.gitgit checkout hexo hexo 环境安装先安装nodejs，后执行npm install 安装相关依赖 123npm install -g hexo-clinpm installnpm install hexo-deployer-git 如果npm速度较慢，建议切换至淘宝的npm 镜像cnpm来安装，具体方法为： 1234npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g hexo-clicmpm installcnpm install hexo-deployer-git 博客书写与代码提交环境安装完成之后，可以愉快写博客啦，博客书写发布需要掌握hexo的相关命令，具体的操作流程如下： 新建一个提交页面 1hexo new &quot;my new post&quot; 在./source/_posts 目录下找到新建的md 文件，对文件进行编辑操作 md文件中需添加title、categories、tags及author字段，格式可参见已提交博客md文件 md文件编辑完成后，可以在本地运行博客服务，查看内容 123hexo clean hexo generate（or hexo g）hexo server （or hexo s） 其中，hexo clean命令可清理已生成的静态页面，hexo generate 命令将markdown文件渲染成静态页面，可简写为hexo g。而hexo server 命令则在本地启动服务器，用于预览主题，可简写为hexo s。如果想直接预览主题，也可跳过前两个命令，直接执行hexo server。 本地博客展示正常，将代码提交至远端仓库，而后将博客发布到远端服务器上 123git commit -m &quot;xxxx&quot;git push origin hexo deploy （or hexo d） 书写博客注意事项 如果博客内容需要修改，建议直接在原文件中编辑，不要删除替换原有文件。因为生成时间是博客的标识之一，随意修改会影响到该篇博客的统计数据。 仓库里面hexo分支为源码分支，master分支为渲染后的静态页面内容，从github上拉取代码后，注意要切换到hexo分支，代码提交和hexo deploy都在此分支执行。 每次hexo deploy发布博客时，仓库中master分支的内容都会被完全覆盖掉，故如无特殊情况，建议大家不要随意修改或者删除hexo分支中已有的博客内容。]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
